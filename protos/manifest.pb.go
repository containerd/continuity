// Code generated by protoc-gen-go.
// source: protos/manifest.proto
// DO NOT EDIT!

/*
Package protos is a generated protocol buffer package.

It is generated from these files:
	protos/manifest.proto

It has these top-level messages:
	Manifest
	Entry
	KeyValue
*/
package protos

import (
	"os"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

// Manifest specifies the entries in a container bundle, keyed and sorted by
// path.
type Manifest struct {
	Entry []*Entry `protobuf:"bytes,1,rep,name=entry" json:"entry,omitempty"`
}

func (m *Manifest) Reset()         { *m = Manifest{} }
func (m *Manifest) String() string { return proto.CompactTextString(m) }
func (*Manifest) ProtoMessage()    {}

func (m *Manifest) GetEntry() []*Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type Entry struct {
	// path specifies the path from the bundle root
	Path  string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	User  string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Group string `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
	Uid   string `protobuf:"bytes,4,opt,name=uid" json:"uid,omitempty"`
	Gid   string `protobuf:"bytes,5,opt,name=gid" json:"gid,omitempty"`
	// mode defines the file mode and permissions. We've used the same
	// bit-packing from Go's os package,
	// http://golang.org/pkg/os/#FileMode, since they've done the work of
	// creating a cross-platform layout.
	Mode os.FileMode `protobuf:"varint,6,opt,name=mode" json:"mode,omitempty"`
	Size uint64      `protobuf:"varint,7,opt,name=size" json:"size,omitempty"`
	// digest specifies the content digest of the target file. Only valid for
	// regular files. The strings are formatted as <alg>:<digest hex bytes>.
	// The digests are added in order of precedence favored by the
	// generating party.
	Digest []string `protobuf:"bytes,8,rep,name=digest" json:"digest,omitempty"`
	// target defines the target of a hard or soft link, relative to the
	// bundle root.
	Target string `protobuf:"bytes,9,opt,name=target" json:"target,omitempty"`
	// specifies major and minor device numbers for charactor and block devices.
	Major uint32 `protobuf:"varint,10,opt,name=major" json:"major,omitempty"`
	Minor uint32 `protobuf:"varint,11,opt,name=minor" json:"minor,omitempty"`
	// xattr provides storage for extended attributes for the target resource.
	Xattr []*KeyValue `protobuf:"bytes,12,rep,name=xattr" json:"xattr,omitempty"`
	// ads stores one or more alternate data streams for the target resource.
	Ads []*KeyValue `protobuf:"bytes,13,rep,name=ads" json:"ads,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}

func (m *Entry) GetXattr() []*KeyValue {
	if m != nil {
		return m.Xattr
	}
	return nil
}

func (m *Entry) GetAds() []*KeyValue {
	if m != nil {
		return m.Ads
	}
	return nil
}

// KeyValue defines a generic key-value mapping type, used for xattrs and NTFS
// Alternate Data Streams.
type KeyValue struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}

func init() {
}
